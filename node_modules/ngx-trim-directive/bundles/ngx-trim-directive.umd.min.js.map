{"version":3,"sources":["ng://ngx-trim-directive/ngx-trim.directive.ts","ng://ngx-trim-directive/ngx-trim-directive.module.ts"],"names":["NgxTrimDirective","elementRef","ngControl","this","trimOnWriteValue","Object","defineProperty","prototype","_trim","trimOption","console","warn","JSON","stringify","elem","nativeElement","eleValue","value","trim","dispatchEvent","getCaret","el","start","selectionStart","end","selectionEnd","setCaret","focus","eventType","event","document","createEvent","initEvent","trimValue","ngOnInit","_this","_valueAccessor","valueAccessor","_writeValue","writeValue","_value","call","ngOnDestroy","onBlur","onInput","_a","Directive","args","selector","ElementRef","NgControl","decorators","type","Optional","Input","HostListener","NgxTrimDirectiveModule","NgModule","imports","declarations","exports"],"mappings":"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","sourcesContent":["import {\n  Directive,\n  ElementRef,\n  HostListener,\n  Input,\n  OnDestroy,\n  OnInit,\n  Optional,\n} from '@angular/core';\nimport {\n  ControlValueAccessor,\n  NgControl,\n} from '@angular/forms';\n\n@Directive({\n  selector: 'input[trim],textarea[trim]',\n})\nexport class NgxTrimDirective implements OnInit, OnDestroy {\n\n  private _trim: '' | 'blur' | false;\n  @Input('trim')\n  public set trim (trimOption: '' | 'blur' | false) {\n    if (trimOption !== '' && trimOption !== 'blur' && trimOption !== false) {\n      console.warn(`Note: The value ${JSON.stringify(trimOption)} is not assignable to the trim attribute.\n        Only blank string (\"\"), \"blur\" or false is allowed.`);\n\n      this._trim = false;\n      return;\n    }\n\n    this._trim = trimOption;\n\n    const elem = this.elementRef.nativeElement;\n    const eleValue = elem.value;\n    if (trimOption !== false && eleValue !== eleValue.trim()) {\n      // initially trim the value if needed\n      NgxTrimDirective.dispatchEvent(elem, 'blur');\n    }\n  }\n\n  public get trim () {\n    return this._trim;\n  }\n\n  @Input() trimOnWriteValue = true;\n\n  private _valueAccessor: ControlValueAccessor;\n  private _writeValue: (value) => void;\n\n  constructor (\n    private elementRef: ElementRef,\n    @Optional() private ngControl: NgControl,\n  ) {\n  }\n\n  private static getCaret (el) {\n\n    return {\n      start: el.selectionStart,\n      end: el.selectionEnd,\n    };\n\n  }\n\n  private static setCaret (el, start, end) {\n\n    el.selectionStart = start;\n    el.selectionEnd = end;\n\n    el.focus();\n\n  }\n\n  private static dispatchEvent (el, eventType) {\n\n    const event = document.createEvent('Event');\n    event.initEvent(eventType, false, false);\n    el.dispatchEvent(event);\n\n  }\n\n  private static trimValue (el, value) {\n\n    el.value = value.trim();\n\n    NgxTrimDirective.dispatchEvent(el, 'input');\n\n  }\n\n  ngOnInit (): void {\n\n    if (!this.ngControl) {\n\n      console.warn('Note: The trim directive should be used with one of ngModel, formControl or formControlName directives.');\n\n      return;\n\n    }\n\n    this._valueAccessor = this.ngControl.valueAccessor;\n\n    this._writeValue = this._valueAccessor.writeValue;\n    this._valueAccessor.writeValue = (value) => {\n      const _value =\n        this.trim === false || !value || 'function' !== typeof value.trim || !this.trimOnWriteValue\n          ? value\n          : value.trim();\n\n      if (this._writeValue) {\n        this._writeValue.call(this._valueAccessor, _value);\n      }\n\n      if (value !== _value) {\n        if (this._valueAccessor['onChange']) {\n          this._valueAccessor['onChange'](_value);\n        }\n\n        if (this._valueAccessor['onTouched']) {\n          this._valueAccessor['onTouched']();\n        }\n      }\n\n    };\n\n  }\n\n  ngOnDestroy (): void {\n\n    if (this._valueAccessor && this._writeValue) {\n\n      this._valueAccessor.writeValue = this._writeValue;\n\n    }\n\n  }\n\n  @HostListener('blur', [\n    '$event.target',\n    '$event.target.value',\n  ])\n  onBlur (el: any, value: string): void {\n\n    if (this.trim === false) {\n\n      return;\n\n    }\n\n    if ((this.trim === '' || 'blur' === this.trim) && 'function' === typeof value.trim && value.trim() !== value) {\n\n      NgxTrimDirective.trimValue(el, value);\n      NgxTrimDirective.dispatchEvent(el, 'blur'); // in case updateOn is set to blur\n\n    }\n\n  }\n\n  @HostListener('input', [\n    '$event.target',\n    '$event.target.value',\n  ])\n  onInput (el: any, value: string): void {\n\n    if (this.trim === false) {\n\n      return;\n\n    }\n\n    if (this.trim === '' && 'function' === typeof value.trim && value.trim() !== value) {\n\n      let { start, end } = NgxTrimDirective.getCaret(el);\n\n      if (value[0] === ' ' && start === 1 && end === 1) {\n\n        start = 0;\n        end = 0;\n\n      }\n\n      NgxTrimDirective.trimValue(el, value);\n\n      NgxTrimDirective.setCaret(el, start, end);\n\n    }\n\n  }\n\n}\n","import { NgModule } from '@angular/core';\nimport { NgxTrimDirective } from './ngx-trim.directive';\n\n@NgModule({\n  imports: [],\n  declarations: [NgxTrimDirective],\n  exports: [NgxTrimDirective],\n})\nexport class NgxTrimDirectiveModule {\n}\n"]}